diff --git a/bfd/elf.c b/bfd/elf.c
index 664eae5c66f..5008a14c598 100644
--- a/bfd/elf.c
+++ b/bfd/elf.c
@@ -752,7 +752,8 @@ setup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)
 	      if (num_group == 0)
 		{
 		  elf_tdata (abfd)->group_sect_ptr = NULL;
-		  elf_tdata (abfd)->num_group = num_group = -1;
+		  num_group = (unsigned int) -1;
+		  elf_tdata (abfd)->num_group = num_group;
 		  _bfd_error_handler
 		    (_("%pB: no valid group sections found"), abfd);
 		  bfd_set_error (bfd_error_bad_value);
diff --git a/gas/config/tc-riscv.c b/gas/config/tc-riscv.c
index 9ecdcab0b63..b4617d9e598 100644
--- a/gas/config/tc-riscv.c
+++ b/gas/config/tc-riscv.c
@@ -688,6 +688,8 @@ validate_riscv_insn (const struct riscv_opcode *opc, int length)
       case 'r':	USE_BITS (OP_MASK_RS3,          OP_SH_RS3);     break;
       case 'P':	USE_BITS (OP_MASK_PRED,		OP_SH_PRED); break;
       case 'Q':	USE_BITS (OP_MASK_SUCC,		OP_SH_SUCC); break;
+      case 'w':	USE_BITS (OP_MASK_BS  ,		OP_SH_BS  ); break; /* Crypto ISE */
+      case 'W':	USE_BITS (OP_MASK_RCON,		OP_SH_RCON); break; /* Crypto ISE */
       case 'o':
       case 'j': used_bits |= ENCODE_ITYPE_IMM (-1U); break;
       case 'a':	used_bits |= ENCODE_UJTYPE_IMM (-1U); break;
@@ -1999,8 +2001,27 @@ rvc_lui:
 		    INSERT_OPERAND (SUCC, *ip, regno);
 		  continue;
 		}
-	      break;
-
+	      break;        
+     /* Crypto ISE - Begin */
+      case 'w': /* BS */
+	        my_getExpression (imm_expr, s);
+	        check_absolute_expr (ip, imm_expr, FALSE);
+            if(imm_expr->X_add_number > 3){as_bad(_("Crypto ISE: 0 <= Byte Select <= 3"));}
+            INSERT_OPERAND(BS,*ip,imm_expr->X_add_number & 0x3);
+            imm_expr->X_op = O_absent;
+            s = expr_end;
+            continue;
+        
+        case 'W': /* RCON  */
+	        my_getExpression (imm_expr, s);
+	        check_absolute_expr (ip, imm_expr, FALSE);
+            if(imm_expr->X_add_number > 10){as_bad(_("Crypto ISE: 0 <= rcon <= 10"));}
+            INSERT_OPERAND(RCON,*ip,imm_expr->X_add_number & 0xF);
+            imm_expr->X_op = O_absent;
+            s = expr_end;
+            continue;
+        
+        /* Crypto ISE - End */
 	    case 'd':		/* Destination register.  */
 	    case 's':		/* Source register.  */
 	    case 't':		/* Target register.  */
diff --git a/include/opcode/riscv-opc.h b/include/opcode/riscv-opc.h
index 6c750a33b18..e06346ffc38 100644
--- a/include/opcode/riscv-opc.h
+++ b/include/opcode/riscv-opc.h
@@ -1,6 +1,20 @@
 /* Automatically generated by parse-opcodes.  */
 #ifndef RISCV_ENCODING_H
 #define RISCV_ENCODING_H
+// Begin Russian Crypto Extension
+#define MATCH_GRASSHOOPER64_L 0x1c00202b
+#define MASK_GRASSHOOPER64_L  0xfe00707f
+#define MATCH_GRASSHOOPER64_RL 0x1e00202b
+#define MASK_GRASSHOOPER64_RL  0xfe00707f
+#define MATCH_GRASSHOOPER64_S 0xc10202b
+#define MASK_GRASSHOOPER64_S  0xfff0707f
+#define MATCH_GRASSHOOPER64_RS 0xc20202b
+#define MASK_GRASSHOOPER64_RS  0xfff0707f
+#define MATCH_STRIBOG64_S 0xc30202b
+#define MASK_STRIBOG64_S  0xfff0707f
+#define MATCH_STRIBOG64_L 0xc40202b
+#define MASK_STRIBOG64_L  0xfff0707f
+// End Russian Crypto Extension
 #define MATCH_SLLI_RV32 0x1013
 #define MASK_SLLI_RV32  0xfe00707f
 #define MATCH_SRLI_RV32 0x5013
diff --git a/include/opcode/riscv.h b/include/opcode/riscv.h
index 7e67c7f9a22..2601217a7e0 100644
--- a/include/opcode/riscv.h
+++ b/include/opcode/riscv.h
@@ -223,6 +223,13 @@ static const char * const riscv_pred_succ[16] =
 #define OP_MASK_RL		0x1
 #define OP_SH_RL		25
 
+/* Crypto ISE - Begin */
+#define OP_SH_BS        30
+#define OP_MASK_BS      3 
+#define OP_SH_RCON      20
+#define OP_MASK_RCON    0xF 
+/* Crypto ISE - End */
+
 #define OP_MASK_CUSTOM_IMM	0x7f
 #define OP_SH_CUSTOM_IMM	25
 #define OP_MASK_CSR		0xfff
diff --git a/opcodes/riscv-dis.c b/opcodes/riscv-dis.c
index 19f10c0e553..2b79095a027 100644
--- a/opcodes/riscv-dis.c
+++ b/opcodes/riscv-dis.c
@@ -296,7 +296,16 @@ print_insn_args (const char *d, insn_t l, bfd_vma pc, disassemble_info *info)
 	    pd->hi_addr[rd] = EXTRACT_RVC_LUI_IMM (l);
 	  print (info->stream, "%s", riscv_gpr_names[rd]);
 	  break;
-
+	/* Crypto ISE - Begin */
+    case 'w': /*BS*/
+	  print (info->stream, "0x%x", (int)EXTRACT_OPERAND (BS, l));
+	  break;
+    
+    case 'W': /* RCON */
+	  print (info->stream, "0x%x", (int)EXTRACT_OPERAND (RCON, l));
+	  break;
+    
+    /* Crypto ISE - End*/
 	case 'z':
 	  print (info->stream, "%s", riscv_gpr_names[0]);
 	  break;
diff --git a/opcodes/riscv-opc.c b/opcodes/riscv-opc.c
index e99febc823f..efa26d2f5ce 100644
--- a/opcodes/riscv-opc.c
+++ b/opcodes/riscv-opc.c
@@ -992,6 +992,14 @@ const struct riscv_opcode riscv_opcodes[] =
 {"sfence.vma", 0, INSN_CLASS_I,   "s,t",  MATCH_SFENCE_VMA, MASK_SFENCE_VMA, match_opcode, 0 },
 {"wfi",        0, INSN_CLASS_I,   "",     MATCH_WFI, MASK_WFI, match_opcode, 0 },
 
+// Russian crypto instructions Begin
+{"grasshooper64.l" ,64, INSN_CLASS_I,    "d,s,t", MATCH_GRASSHOOPER64_L, MASK_GRASSHOOPER64_L, match_opcode, 0},
+{"grasshooper64.rl" ,64, INSN_CLASS_I,    "d,s,t", MATCH_GRASSHOOPER64_RL, MASK_GRASSHOOPER64_RL, match_opcode, 0},
+{"grasshooper64.s" ,64, INSN_CLASS_I,    "d,s", MATCH_GRASSHOOPER64_S, MASK_GRASSHOOPER64_S, match_opcode, 0},
+{"grasshooper64.rs" ,64, INSN_CLASS_I,    "d,s", MATCH_GRASSHOOPER64_RS, MASK_GRASSHOOPER64_RS, match_opcode, 0},
+{"stribog64.s" ,64, INSN_CLASS_I,    "d,s", MATCH_STRIBOG64_S, MASK_STRIBOG64_S, match_opcode, 0},
+{"stribog64.l" ,64, INSN_CLASS_I,    "d,s", MATCH_STRIBOG64_L, MASK_STRIBOG64_L, match_opcode, 0},
+// Russian crypto instructions End
 /* Terminate the list.  */
 {0, 0, INSN_CLASS_NONE, 0, 0, 0, 0, 0}
 };
